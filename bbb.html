<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KKKang 爱心动画（HTML5 Canvas 版）</title>
  <style>
    html,body{height:100%;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#000}
    canvas{background:#000;display:block}
  </style>
</head>
<body>
  <canvas id="heartCanvas" width="640" height="480"></canvas>

  <script>
    // 常量（尽量保留与原 Python 代码相同的数值）
    const CANVAS_WIDTH = 640;
    const CANVAS_HEIGHT = 480;
    const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
    const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2;
    const IMAGE_ENLARGE = 11;
    const HEART_COLOR = '#FF99CC';

    // JS 版的心形函数（与 Python 的 heart_function 对应）
    function heart_function(t, shrink_ratio = IMAGE_ENLARGE) {
      const x0 = 16 * Math.pow(Math.sin(t), 3);
      const y0 = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
      let x = x0 * shrink_ratio + CANVAS_CENTER_X;
      let y = y0 * shrink_ratio + CANVAS_CENTER_Y;
      return [Math.floor(x), Math.floor(y)];
    }

    function randChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function scatter_inside(x, y, beta = 0.15) {
      const ratio_x = -beta * Math.log(Math.random());
      const ratio_y = -beta * Math.log(Math.random());
      const dx = ratio_x * (x - CANVAS_CENTER_X);
      const dy = ratio_y * (y - CANVAS_CENTER_Y);
      return [x - dx, y - dy];
    }

    function shrink(x, y, ratio) {
      const dist2 = Math.pow((x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2, 0.6);
      const force = -1 / (dist2 === 0 ? 1e-6 : dist2);
      const dx = ratio * force * (x - CANVAS_CENTER_X);
      const dy = ratio * force * (y - CANVAS_CENTER_Y);
      return [x - dx, y - dy];
    }

    function curve(p) {
      return 2 * (2 * Math.sin(4 * p)) / (2 * Math.PI);
    }

    // Heart 类：负责生成点、预计算每帧的数据并渲染
    class Heart {
      constructor(generate_frame = 20) {
        this._points = new Set();
        this._edge_diffusion_points = new Set();
        this._center_diffusion_points = new Set();
        this.all_points = {};
        this.random_halo = 1000; // 保留但未直接使用
        this.generate_frame = generate_frame;
        this.build(2000);
        // 预计算每一帧
        for (let frame = 0; frame < generate_frame; frame++) {
          this.calc(frame);
        }
      }

      // 用字符串 key 保存点以便去重（与 Python 的集合行为一致）
      _addPointToSet(setRef, x, y) {
        setRef.add(`${Math.floor(x)},${Math.floor(y)}`);
      }

      _setToArray(setRef) {
        const arr = [];
        for (const kv of setRef) {
          const [xs, ys] = kv.split(',');
          arr.push([parseInt(xs, 10), parseInt(ys, 10)]);
        }
        return arr;
      }

      build(number) {
        // 主轮廓点
        for (let i = 0; i < number; i++) {
          const t = Math.random() * 2 * Math.PI;
          const [x, y] = heart_function(t);
          this._addPointToSet(this._points, x, y);
        }

        // 爱心内边缘扩散（每个点向内扩散 3 次）
        for (const kv of Array.from(this._points)) {
          const [xs, ys] = kv.split(',');
          const _x = parseInt(xs, 10), _y = parseInt(ys, 10);
          for (let j = 0; j < 3; j++) {
            const [nx, ny] = scatter_inside(_x, _y, 0.05);
            this._addPointToSet(this._edge_diffusion_points, nx, ny);
          }
        }

        // 爱心内再次大量扩散
        const point_list = Array.from(this._points);
        for (let i = 0; i < 4000; i++) {
          const kv = randChoice(point_list);
          const [px, py] = kv.split(',').map(v => parseInt(v, 10));
          const [nx, ny] = scatter_inside(px, py, 0.17);
          this._addPointToSet(this._center_diffusion_points, nx, ny);
        }

        // 将集合转换为数组备后用
        this._points_arr = this._setToArray(this._points);
        this._edge_arr = this._setToArray(this._edge_diffusion_points);
        this._center_arr = this._setToArray(this._center_diffusion_points);
      }

      static calc_position(x, y, ratio) {
        const distPow = Math.pow((x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2, 0.520);
        const force = 1 / (distPow === 0 ? 1e-6 : distPow);
        const dx = ratio * force * (x - CANVAS_CENTER_X) + (Math.floor(Math.random() * 3) - 1);
        const dy = ratio * force * (y - CANVAS_CENTER_Y) + (Math.floor(Math.random() * 3) - 1);
        return [x - dx, y - dy];
      }

      calc(generate_frame) {
        const ratio = 10 * curve(generate_frame / 10 * Math.PI);
        const halo_radius = Math.floor(4 + 6 * (1 + curve(generate_frame / 10 * Math.PI)));
        const halo_number = Math.floor(3000 + 4000 * Math.pow(Math.abs(curve(generate_frame / 10 * Math.PI)), 2));

        const all_points = [];

        // 光环
        const heart_halo_point = new Set();
        for (let i = 0; i < halo_number; i++) {
          const t = Math.random() * 2 * Math.PI;
          let [x, y] = heart_function(t, 11.6);
          [x, y] = shrink(x, y, halo_radius);
          const key = `${Math.floor(x)},${Math.floor(y)}`;
          if (!heart_halo_point.has(key)) {
            heart_halo_point.add(key);
            x += Math.floor(Math.random() * 29) - 14; // -14..14
            y += Math.floor(Math.random() * 29) - 14;
            const size = randChoice([1, 2, 2]);
            all_points.push([Math.floor(x), Math.floor(y), size]);
          }
        }

        // 轮廓
        for (const [x0, y0] of this._points_arr) {
          const [x, y] = Heart.calc_position(x0, y0, ratio);
          const size = Math.floor(Math.random() * 3) + 1; // 1..3
          all_points.push([Math.floor(x), Math.floor(y), size]);
        }

        // 内容（边缘扩散）
        for (const [x0, y0] of this._edge_arr) {
          const [x, y] = Heart.calc_position(x0, y0, ratio);
          const size = Math.floor(Math.random() * 2) + 1; // 1..2
          all_points.push([Math.floor(x), Math.floor(y), size]);
        }

        // 中心扩散
        for (const [x0, y0] of this._center_arr) {
          const [x, y] = Heart.calc_position(x0, y0, ratio);
          const size = Math.floor(Math.random() * 2) + 1;
          all_points.push([Math.floor(x), Math.floor(y), size]);
        }

        this.all_points[generate_frame] = all_points;
      }

      render(ctx, render_frame) {
        const frame_points = this.all_points[render_frame % this.generate_frame];
        for (const [x, y, size] of frame_points) {
          ctx.fillRect(x, y, size, size);
        }
      }
    }

    // 初始化并开始动画
    (function () {
      const canvas = document.getElementById('heartCanvas');
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = HEART_COLOR;

      const heart = new Heart();
      let render_frame = 0;
      const FRAME_INTERVAL = 160; // 与原 Python 的 after(160) 保持一致
      let lastTime = performance.now();

      function loop(now) {
        const elapsed = now - lastTime;
        if (elapsed >= FRAME_INTERVAL) {
          lastTime = now - (elapsed % FRAME_INTERVAL);

          // 清空画布
          ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          // 设置填充颜色（每次都设置确保一致）
          ctx.fillStyle = HEART_COLOR;
          heart.render(ctx, render_frame);
          render_frame++;
        }
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    })();

  </script>
</body>
</html>
